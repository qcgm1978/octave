A = reshape (1:8, 2, 2, 2) ;# Create 3-D arrayassert(class(A),'double')assert(typeinfo(A),'matrix')assert(A(2, 1, 2),6)assert(A(1,1,2),5)#assert(A,[[[1,3;2,4]]])isequal(A([1, 2], 1, 2),[A(1,1,2); A(2,1,2)],[5;6]);assert(A(1, [2, 1, 1], 1),[3 1 1])assert(A(ones (2, 2), 1, 1),[1 ;1; 1; 1])#the shape of the indexing component is irrelevant, it is only the number of elements (2x2 = 4)#for one-dimensional index expressions special rules apply and the shape of the output is determined by the shape of the indexing component  assert(A([1, 2]),[1,2])assert( A([1; 2]),[1;2])assert(A(5),5)assert(A(3:5),[3,4,5])A = [1, 2; 3, 4];column2=A(1, [1, 2]) ;# row 1, columns 1 and 2range2=A(1, 1:2); # row 1, columns in range 1-2 allCols=A(1, :); # row 1, all columnsisequal(column2,range2,allCols,[1,2]);#Creating column vectors with a colon index is a very frequently encountered code idiomfail('A([1,2;3;4])','vertical dimensions mismatch')isequal(A(:),A([1;2;3;4]),[1;3;2;4]);A(:)';isequal(A(:)',A([1,2,3,4]),[1,3,2,4]);#the keyword end automatically refers to the last entry for a partic- ular dimension.assert(A(1:end/2),[1,3])fail('A(end + 1) = 5','Invalid resizing operation or ambiguous assignment to an out-of-bounds array element')A(end) = [];assert(A,[1 3 2])assert(A(1:2:end),[1,2])assert(A(2:2:end),3)assert(A(end:-1:1),[2 3 1])