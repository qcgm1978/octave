global checkfunction check (varargin)  p = inputParser ();  p.FunctionName = "check";  p.addRequired ("pack", @ischar); p.addOptional ("path", pwd(), @ischar);  # create object  # set function name  # mandatory argument  # optional argument  ## create a function handle to anonymous functions for validators val_mat = @(x) isvector (x) && all (x <= 1) && all (x >= 0); p.addOptional ("mat", [0 0], val_mat);  ## create two arguments of type "Parameter"  val_type = @(x) any (strcmp (x, {"linear", "quadratic"})); p.addParameter ("type", "linear", val_type);  val_verb = @(x) any (strcmp (x, {"low", "medium", "high"})); p.addParameter ("tolerance", "low", val_verb);  ## create a switch type of argument p.addSwitch ("verbose");  p.parse (varargin{:}); # Run created parser on inputs  ## the rest of the function can access inputs by using p.Results.  ## for example, get the tolerance input with p.Results.tolerance endfunction  check ("mech")  check ()  check (1)  check ("mech", "~/dev")# valid, use defaults for other arguments  # valid, use defaults for other arguments  # error, one argument is mandatory  # error, since ! ischar  check ("mech", "~/dev", [0 1 0 0], "type", "linear"); # valid  ## following is also valid. Note how the Switch argument type can ## be mixed into or before the Parameter argument type (but it  ## must still appear after any Optional argument).  check ("mech", "~/dev", [0 1 0 0], "verbose", "tolerance", "high");  ## following returns an error since not all optional arguments, ## ‘path' and ‘mat', were given before the named argument ‘type'. check ("mech", "~/dev", "type", "linear");