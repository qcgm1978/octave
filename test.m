clcclear a = [1;2]; b=[4;8]; assert (mean(a)>=mean(a,"g")); assert(mean(b)==6); assert(mean(a,"g")>mean(a,"h")); function retval = getSumMin (v);   if(v(1)>0&&v(2)>0)     retval = 2*mean(v,"g");   endif     endfunctionassert(a(1)==1)c=[2;8];assert(getSumMin(c)=8);##printf("%.2f%%",.5/300*100)assert(cos(1)/sin(1)>0);function y = f (x)   y = x**2;   endfunctionassert(f(3)==9)# f()function countdown       # Count down for main rocket engines       disp (3);       disp (2);       disp (1);       disp ("Blast Off!");  # Rocket leaves padendfunction#countdown()function xdot = f1 (x, t)# usage: f (x, t)## 1This function defines the right-hand # side functions for a set of nonlinear # differential equations.r = 0.25; ...endfunction assert(typeinfo(1)=="scalar");#typeinfo(1)class({});isa(1,"float");assert(isa(1,"float")==1)isa(1,"float");assert(isa(1,"numeric")==1)isa(1,"float");assert(isa(1,"integer")==0)assert(cast (-5, "uint8")==0)assert(cast (300, "int8")==127)y=( typecast (300, "int8"));z=typeinfo(y);assert(z=="int8 matrix");x = uint16 ([1, 65535]); g=typecast (x, "uint8");assert(g==[ 1, 0, 255, 255]);assert(realmin!=2.2251e-308)assert(NA!=NA)assert(isna(NA)==1)assert(NA()!=NA)assert(isna ([13, Inf, NA, NaN])==[0,0,1,0])assert(ndims (ones (4, 1, 2, 1))==3)a = 1;b = ones (2, 3); c=numel (a, b);assert(c==6)a = ones (5, 3); assert(numel (a, 2, ":")==3)assert(size ([1, 2; 3, 4; 5, 6])==[3,2])assert(size ([1, 2; 3, 4; 5, 6],2)==2)[nr, nc] = size ([1, 2; 3, 4; 5, 6]);assert(nr==3)assert(nc==2)[nr, remainder] = size (ones (2, 3, 4, 5));assert(nr==2)assert(remainder==60)A=ones(2,3);assert(isnull(A)==0)assert(isnull(A)==0)assert(A=[1;1;1;1;1;1])assert(7*1e9*1e9*1e9==7e27)fail("1=2")assert(pi,3.1416,7e-05)assert(I,sqrt(-1))assert(Inf,Inf)##assert(symvar ("x^2 + y^2 == 4"),[1;1];[2;1])v=20;d=.01;f=.2*v/d;assert(f,400)d=.005;f1=.2*v/d;assert(f1,800)assert(dec2bin(17),'10001')assert(dec2bin(100),'1100100')assert(bin2dec('1010100'),84)isequal(2^6<100,2^7>100,7-6==1);function f=KarmanVortexStreet(v,d)  f=.2*v/d;  endfunctionassert(  KarmanVortexStreet(20,.01),400)assert(  KarmanVortexStreet(20,.005),800)function a=getAcceleratedSpeed(T,r) a=( 2*pi/T)^2*r; endfunction T=27.3*24*3600; r=3.84e8; moonAccelerated=getAcceleratedSpeed(T,r);assert( moonAccelerated,2.72e-3,5e-6)acceleratedRatio=moonAccelerated/9.8;assert(acceleratedRatio,1/3600,3e-7)function ratio=getAcceleratedRatio(r1,r2)  ratio=(r2/r1)^2;  endfunctionratio=  getAcceleratedRatio(380e6,6400e3);assert( ratio,acceleratedRatio,6e-6)function mat=getMatrix(mSize)  mat=zeros(mSize);  for i=1:mSize(1)*mSize(2)  [row,col]=ind2sub(mSize,i);  mat(i)=abs(row-col)+1;  endfor  endfunctionisequal(getMatrix([3 3]),[1 2 3;2 1 2;3 2 1])isequal(getMatrix([5 4])(5,4),2)isequal([1 2].+[3 4],[1 2]+[3 4],[1+3,2+4],[1.+3,2.+4],[4,6])#syms x#L = limit(sin(x)/x, x, 0)#: norm (A)#: norm (A, p)#: norm (A, p, opt)#Compute the p-norm of the matrix A. #If the second argument is not given, p = 2is used. #If A is a matrix (or sparse matrix): A = [0 1 2; 0.5 0 1; 2 1 0];sumA=0;#1-norm, the largest column sum of the absolute values of A. for i=1:columns(A)  sumCol=sum(A(:,i));  if(sumCol>sumA)  sumA=sumCol;  endif  end  isequal(norm(A,p = 1),sumA)#p = 2#Largest singular value of A. #singular value: square roots of the eigenvalues of the non-negativeassert(max(svds(A)),norm(A,2),4e-15)#p = Inf or "inf"#Infinity norm, the largest row sum of the absolute values of A. #p = "fro"#Frobenius norm of A, sqrt (sum (diag (A' * A))). #other p, p > 1#maximum norm (A*x, p) such that norm (x, p) == 1 #If A is a vector or a scalar: #p = Inf or "inf"#max (abs (A)). #p = -Inf#min (abs (A)). #p = "fro"#Frobenius norm of A, sqrt (sumsq (abs (A))). #p = 0#Hamming normâ€”the number of nonzero elements. #other p, p > 1#p-norm of A, (sum (abs (A) .^ p)) ^ (1/p). #other p p < 1#the p-pseudonorm defined as above. #If opt is the value "rows", treat each row as a vector and compute its norm. The result is returned as a column vector. Similarly, if opt is "columns" or "cols" then compute the norms of each column and return a row vector. ##########