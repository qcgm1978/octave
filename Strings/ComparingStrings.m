GNU = "GNU's Not UNIX";len=length(GNU);spaces = (GNU == " ");isequal(length(spaces),len,14);assert(spaces,logical([0,0,0,0,0,1,0,0,0,1,0,0,0,0]))assert(strcmp("abc","abc"),"Return 1 if the character strings s1 and s2 are the same, and 0 otherwise.")assert(strncmp ("abce", "abcd", 3),"Return 1 if the first n characters of strings s1 and s2 are the same, and 0 otherwise.")assert(strncmp ("abce", {"abcd", "bca", "abc"}, 3),[true,false,true])#may also be a cell array of stringsassert(strcmpi("abc","ABC"),"disregarding case of alpha- betic characters")assert(strncmpi("abc","abC",3))quote = "First things first, but not necessarily in that order";quote( quote == " " ) = "_";assert(quote,"First_things_first,_but_not_necessarily_in_that_order")assert(deblank ("   abc   "),"   abc")assert(deblank ([" abc "; " def "]),[" abc";" def"])assert(strtrim (" abc "),"abc");assert(strtrim ([" abc "; " def "]),["abc";"def"])assert(index ("Teststring", "t"),4)assert(rindex ("Teststring", "t"),6)assert(strfind ("abababa", "aba"),[1,3,5])assert(strfind ("abababa", "aba", "overlaps", false),[1,5])#only for unique occurrences of the complete pattern##assert(    strfind ({"abababa", "bebebe", "ab"}, "aba"),{[1,1],[1,2],[1,3]})assert(strjoin ({'Octave','Scilab','Lush','Yorick'}, '*'),"Octave*Scilab*Lush*Yorick")assert(strtok ("this is the life"),"this")#If delim is not specified, whitespace is assumedassert([tok, rem] = strtok ("14*27+31", "+-*/"),["14"])assert(tok,"14")assert(rem,'*27+31')#If rem is requested, it contains the remainder of the string, starting at the first de-limiter.assert( strsplit ("a b c"),{"a","b","c"})#return a cell string array of substrings.assert(strsplit ("a,b,c", ","),{'a','b','c'})#Split the string str using the delimiters specifiedassert(strsplit ("a foo b,bar c", {" ", ",", "foo", "bar"}),{'a' 'b' 'c'})#consecutive delimiters in the input string s are collapsed into one resulting in a single split#  assert(  strsplit ("a,,b, c", {",", " "}, "collapsedelimiters", false),{'a' '' 'b' " " 'c'})#• collapsedelimiters which may take the value of true (default) or false.assert(strsplit ("a foo b,bar c", ',|\s|foo|bar', "delimitertype", "regularexpression"),{'a' 'b' 'c'})assert(ostrsplit ("a,b,c", ","),{'a' 'b' 'c'})assert(         ostrsplit (["a,b" ; "cde"], ","),{'a','b','cde'})#Split the string s using one or more separators sep and return a cell array of strings.assert(strrep ("This is a test string", "is", "&%$"),'Th&%$ &%$ a test string')#Replace all occurrences of the pattern ptn in the string str with the string rep and return the result#Delete all occurrences of ptn within str.assert(erase ("Hello World!", " World"),'Hello!')assert(         erase ({"Hello", "World!"}, "World"),{'Hello' '!'})assert(erase ("The Octave interpreter is fabulous", {"interpreter ", "The "}),"Octave is fabulous")assert(erase ({"The ", "Octave interpreter ", "is fabulous"},{"interpreter ", "The "}),{'','Octave ','is fabulous'})assert(erase ("abababa", "aba"),'b')#Return the substring of s which starts at character number offset and is len charactersassert(substr ("This is a test string", 6, 9),'is a test')assert(substr ("This is a test string", -11),'test string')assert(substr ("This is a test string", -11, -7),'test')assert(regexp ('a', 'b*', 'emptymatch'),[1,2])#there are zero or more 'b' characters at positions 1 and end-of-string.assert(regexprep ("Bill Dunn", '(\w+) (\w+)', '$2, $1'),'Dunn, Bill')assert(regexptranslate ("wildcard", "*.m"),'.*\.m')#The wildcard characters ., *, and ? are replaced with wildcards that are appropriate for a regular expression.assert(regexptranslate ("escape", "12.5"),'12\.5')#The characters $.?[], that have special meaning for regular expressions are escaped so that they are treated literally#reads a file and writes an untabified version of the same file with trailing spaces strippedfid = fopen ("tabbed_script.m");text = char (fread (fid, "uchar")');fclose (fid);fid = fopen ("untabified_script.m", "w");text = untabify (strsplit (text, "\n"), 8, true); fprintf (fid, "%s\n", text{:});fclose (fid);fail('unicode_idx ("a ̈abc")')